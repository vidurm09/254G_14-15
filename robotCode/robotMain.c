#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    rightPot,       sensorPotentiometer)
#pragma config(Sensor, in2,    leftPot,        sensorPotentiometer)
#pragma config(Sensor, in4,    sideLeft,       sensorLineFollower)
#pragma config(Sensor, in5,    sideRight,      sensorLineFollower)
#pragma config(Sensor, in6,    centerLeft,     sensorLineFollower)
#pragma config(Sensor, in7,    centerMid,      sensorLineFollower)
#pragma config(Sensor, in8,    centerRight,    sensorLineFollower)
#pragma config(Sensor, dgtl1,  leftArmButtonTop, sensorDigitalIn)
#pragma config(Sensor, dgtl2,  leftArmButton,  sensorDigitalIn)
#pragma config(Sensor, dgtl3,  rightArmButton, sensorDigitalIn)
#pragma config(Sensor, dgtl4,  rightArmButtonTop, sensorDigitalIn)
#pragma config(Sensor, dgtl8,  solenoid,       sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           RF,            tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port2,           IR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           IL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           LB,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           LF,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           ARB,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           ART,           tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port8,           ALB,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           ALT,           tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port10,          RB,            tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"


//Temp

float leftArmAngle;
float rightArmAngle;

float targetValue;
float leftDriveTargetValue=0;
float rightDriveTargetValue=0;
int rightArmTarget;
int leftArmTarget;
float left_currAngle;
float right_currAngle;
float currLeftDist;
float currRightDist;
float left_armAngle;
float right_armAngle;
float targetLeftDist;
float targetRightDist;
float left_armPow;
float right_armPow;
bool armMove;
bool armA;
bool driveA;
int armLoop = 0;
float right_inte;
float left_inte;
float armAngle;
bool softStop = false;
bool softStopTop = false;
int prevArmPosRight;
int prevArmPosLeft;

#include "robotArm.c"
#include "robotDrive.c"
#include "robotAuto.c"

void pre_auton()
{
  bStopTasksBetweenModes = true;
	targetValue=4000;
  rightArmTarget = 0;
  leftArmTarget = 0;
  left_armAngle = 0;
  right_armAngle = 0;
}


void resetEncoders()
{
	nMotorEncoder[LB] = 0;
	nMotorEncoder[RB] = 0;
	nMotorEncoder[ALT] = 0;
	nMotorEncoder[ART] = 0;
}

void drive()
{

	//int right_armVal;
	//int left_armVal;
  tank();
	//arcade();
  //Arm control
	driveArmPID();
	//driveArm();
	/*if (vexRT[Btn6D]== 1 && !softStop)
	{
		setLeftArm(-127);
		setRightArm(-127);
	}
else if (vexRT[Btn6U] == 1 && !softStopTop)
	{
		setRightArm(127);
		setLeftArm(127);
	}
	else
	{
		setRightArm(0);
		setLeftArm(0);
	}*/


	//armPresets();
	//Intake control

	if (vexRT[Btn7D] == 1)
	{
		SensorValue[solenoid] = 1;

	}
	if (vexRT[Btn7L] == 1)
	{
		SensorValue[solenoid] = 1;
		wait1Msec(2000);
		SensorValue[solenoid] = 0;

	}
	if (vexRT[Btn7U] == 1)
	{
		SensorValue[solenoid] = 0;
	}

	if (vexRT[Btn5U]== 1)
	{
		motor[IR]=-127;
		motor[IL]=-127;
	}
	else if (vexRT[Btn5D] == 1)
	{
		motor[IR]=127;
		motor[IL]=127;
	}
	else
	{
		motor[IR]=0;
		motor[IL]=0;
	}
	if (vexRT[Btn8U] == 1)
	{
	left_armAngle = 30;
	right_armAngle = 30;
	}
	else if (VexRT[Btn8D] ==1)
{
	left_armAngle = 0;
	right_armAngle = 0;

}
	if (sensorValue[leftArmButton] == 0 || sensorValue[rightArmButton]==0)
	{
		softStop = true;
	}
	else
	{
		softStop = false;
	}

	if (sensorValue[leftArmButtonTop] == 0 || sensorValue[rightArmButtonTop]==0)
	{
		softStopTop = true;
	}
	else
	{
		softStopTop = false;
	}
	/*right_armVal = SensorValue[leftPot];
	left_armVal = SensorValue[rightPot];
	armPID(right_armVal,left_armVal);*/
}


task usercontrol()
{
	while (true)
	{
		if (vexRT[Btn8D])
		{
			while(true)
			{
				lineSensorNonSky();
			}
		}
		drive();
		/*if(vexRT[Btn7D])
		{
			startTask(stopAll);
			startTask(arm);
			startTask(driveBasePID);
				//dropSmallPoleBlue();
			//moveBackDrop();
			//dropMediumPoleBlueSky();
			//ndropCube();
			wait1Msec(10000);
			stopTask(arm);
			stopTask(driveBasePID);
		}
			/*
				_   _     _   _   _   _   _
			 / \ / \   / \ / \ / \ / \ / \
			( H | I ) ( V | I | D | U | R )
			 \_/ \_/   \_/ \_/ \_/ \_/ \_/
		*/
		leftArmAngle = getLeftArm();
		rightArmAngle = getRightArm();
		writeDebugStreamLine("Left: %f, Right: %f",  getLeftArm(), getRightArm());
	}
}
